<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Top 10 Animes por Temporada (MAL + AniList)</title>
<style>
body {
    font-family: Arial, sans-serif;
    background:#000;
    color:#fff;
    text-align:center;
    margin:0;
    padding:20px;
}
h1 {
    color:#cc0000;
    font-size:2.6em;
    text-shadow:0 0 10px rgba(204,0,0,.5);
}
.controls { 
    margin:30px auto; 
    max-width: 1400px;
}
select, button {
    padding:12px;
    font-size:1.05em;
    margin:10px;
    border-radius:8px;
    border:2px solid #cc0000;
    background:#111;
    color:#fff;
}
button {
    cursor:pointer;
    background:linear-gradient(45deg,#cc0000,#ff3333);
}
button:hover { transform:scale(1.05); }
.grid {
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:25px;
    max-width:1400px;
    margin:40px auto;
}
.anime-card {
    background:#111;
    border-radius:15px;
    padding:15px;
    box-shadow:
        0 0 15px rgba(204,0,0,.25),
        0 10px 25px rgba(0,0,0,.6);
    transition:.3s;
    display: flex;
    flex-direction: column;
    animation: fadeUp .4s ease;
}
.anime-card:hover {
    transform: translateY(-6px) scale(1.02);
}
.anime-card img {
    width:100%;
    border-radius:12px;
    border:2px solid #cc0000;
    height: 300px;
    object-fit: cover;
}
.rank {
    font-size:2.1em;
    font-weight:bold;
}
.rank.gold { color: gold; text-shadow: 0 0 8px gold; }
.rank.silver { color: silver; text-shadow: 0 0 6px silver; }
.rank.bronze { color: #cd7f32; text-shadow: 0 0 6px #cd7f32; }
.rank.red { color:#cc0000; }
.title {
    font-weight: bold;
    font-size: 1.05em;
    margin: 5px 0;
    line-height: 1.2em;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 4;
    overflow: hidden;
    min-height: 6em;
}
.scores {
    font-size: 0.85em;
    color: #aaa;
    margin: 3px 0;
    min-height: 2.4em;
}
.average {
    font-size:1.6em;
    color:#ff0;
    text-shadow:0 0 8px rgba(255,255,0,.6);
    margin-bottom: 14px;
}
.links a {
    color:#ff6666;
    margin:0 8px;
    text-decoration:none;
}
.links a:hover { text-decoration:underline; }

/* Edición manual */
.al-score {
    cursor: pointer;
    color: #ff6666;
    font-weight: bold;
}
.al-score:hover { text-decoration: underline; }
.edit-input {
    width: 60px;
    padding: 4px;
    background: #222;
    color: #fff;
    border: 1px solid #cc0000;
    border-radius: 4px;
    text-align: center;
}

/* Barra de progreso */
.progress-container {
    width: 60%;
    max-width: 800px;
    margin: 30px auto;
    background: #222;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(204,0,0,.6);
    display: none;
}
.progress-bar {
    width: 0%;
    height: 30px;
    background: linear-gradient(90deg, #cc0000, #ff4444);
    border-radius: 10px;
    transition: width 0.4s ease;
    position: relative;
}
.progress-text {
    position: absolute;
    width: 100%;
    text-align: center;
    line-height: 30px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 3px black;
}

.skeleton {
    background:#111;
    border-radius:15px;
    padding:15px;
    box-shadow: 0 0 15px rgba(204,0,0,.25), 0 10px 25px rgba(0,0,0,.6);
    height: 520px;
    background: linear-gradient(90deg, #111, #222, #111);
    background-size: 200% 100%;
    animation: pulse 1.5s infinite;
}
@keyframes pulse {
    0% { background-position:0% }
    100% { background-position:200% }
}
@media(max-width:1200px){ .grid{grid-template-columns:repeat(3,1fr);} }
@media(max-width:800px){ 
    .grid{grid-template-columns:repeat(2,1fr);} 
    .progress-container { width: 90%; }
}
@keyframes fadeUp {
    from { opacity: 0; transform: translateY(10px); }
    to   { opacity: 1; transform: translateY(0); }
}

/* Ajustes para que el dropdown quede con la misma altura y estilo */
#scoreMode {
    padding: 8px 12px;
    font-size: 1.1em;
    border-radius: 8px;
    border: 2px solid #cc0000;
    background: #111;
    color: #fff;
    min-height: 38px;
    cursor: pointer;
}
#scoreMode option {
    background: #111;
    color: #fff;
}
#scoreMode:hover {
    border-color: #ff4444;
    box-shadow: 0 0 8px rgba(204,0,0,0.4);
}

/* Paginación alineada con el botón Buscar */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-top: 25px;
}
.pagination button {
    font-size: 1.1em;
    background: linear-gradient(45deg,#cc0000,#ff3333);
    border: 2px solid #cc0000;
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
    padding: 12px 24px;
    min-width: 140px;
    transition: transform .2s;
}
.pagination button:hover {
    transform: scale(1.05);
}
</style>
</head>
<body>
<h1>Top 10 Animes por Temporada</h1>

<div id="updateInfo" style="margin: 15px auto; font-size: 1.1em; color: #ff9999; min-height: 1.5em;">
    Próxima actualización en: <span id="countdown">--:--:--</span>
</div>

<div id="loading" class="loading">Seleccioná temporada y año</div>

<div class="controls">
    <select id="year"></select>
    <select id="season">
        <option value="winter">Winter</option>
        <option value="spring">Spring</option>
        <option value="summer">Summer</option>
        <option value="fall">Fall</option>
    </select>

    <!-- Checkboxes + dropdown juntos -->
    <div style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; margin: 15px auto;">
        <div class="type-filters" style="font-size: 1.1em; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <label><input type="checkbox" id="type-tv" checked disabled> TV</label>
            <label><input type="checkbox" id="type-ona" checked> ONA</label>
            <label><input type="checkbox" id="type-movie" checked> Movie</label>
            <label><input type="checkbox" id="type-ova" checked> OVA</label>
            <label><input type="checkbox" id="type-special" checked> Special</label>
        </div>

        <!-- Dropdown al lado -->
        <div style="display: flex; align-items: center; gap: 10px; white-space: nowrap;">
            <label for="scoreMode" style="font-size: 1.1em;">Mostrar puntajes como:</label>
            <select id="scoreMode">
                <option value="normal">Del 1 al 10</option>
                <option value="percent">Porcentual</option>
            </select>
        </div>
    </div>

    <button onclick="loadTop10()">Buscar</button>

    <!-- Paginación dentro de .controls -->
    <div class="pagination">
        <button id="prevPage">Anterior</button>
        <button id="nextPage">Siguiente</button>
    </div>
</div>

<div id="progressContainer" class="progress-container">
    <div id="progressBar" class="progress-bar">
        <div id="progressText" class="progress-text">0%</div>
    </div>
</div>

<!-- Contenedor del grid -->
<div id="grid" class="grid"></div>


<script>
const CACHE_TTL = 4 * 60 * 60 * 1000;     // 4 horas
const MAX_SEASONS_CACHED = 25;
const BATCH_SIZE = 15;

const grid = document.getElementById('grid');
const loading = document.getElementById('loading');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
let seasonRanking = []; // Lista completa de la temporada
let currentPage = 1;
const itemsPerPage = 10;


window.onload = () => {
    const y = document.getElementById('year');
    const currentYear = new Date().getFullYear();
    
    // Generamos opciones desde el año actual +2 hasta 1990
    for (let i = currentYear + 2; i >= 1990; i--) {
        const o = document.createElement('option');
        o.value = i;
        o.textContent = i;
        y.appendChild(o);
    }

    // Restaurar año guardado
    const savedYear = localStorage.getItem('selectedYear');
    if (savedYear && y.querySelector(`option[value="${savedYear}"]`)) {
        y.value = savedYear;
    } else {
        // Fallback: año actual (o próximo si ya estamos en Q4, pero por simplicidad usamos current)
        y.value = currentYear;
    }

    // Restaurar temporada
    const savedSeason = localStorage.getItem('selectedSeason');
    if (savedSeason) {
        const seasonSelect = document.getElementById('season');
        if (seasonSelect.querySelector(`option[value="${savedSeason}"]`)) {
            seasonSelect.value = savedSeason;
        }
    }

    // Restaurar tipos (ONA, Movie, etc.)
    const savedTypes = JSON.parse(localStorage.getItem('selectedTypes') || '[]');
    document.getElementById('type-ona').checked = savedTypes.includes("ONA");
    document.getElementById('type-movie').checked = savedTypes.includes("Movie");
    document.getElementById('type-ova').checked = savedTypes.includes("OVA");
    document.getElementById('type-special').checked = savedTypes.includes("Special");

    // Iniciar countdown
    startCountdown();

    // Guardar cambios en localStorage
    y.addEventListener('change', () => {
        localStorage.setItem('selectedYear', y.value);
        startCountdown();
    });

    document.getElementById('season').addEventListener('change', () => {
        localStorage.setItem('selectedSeason', document.getElementById('season').value);
        startCountdown();
    });

    // Guardar cambios en checkboxes y invalidar caché si cambia
    const checkboxes = document.querySelectorAll('.type-filters input[type="checkbox"]:not([disabled])');
    checkboxes.forEach(chk => {
        chk.addEventListener('change', () => {
            const selectedTypes = [];
            if (document.getElementById('type-ona').checked) selectedTypes.push("ONA");
            if (document.getElementById('type-movie').checked) selectedTypes.push("Movie");
            if (document.getElementById('type-ova').checked) selectedTypes.push("OVA");
            if (document.getElementById('type-special').checked) selectedTypes.push("Special");
            localStorage.setItem('selectedTypes', JSON.stringify(selectedTypes));

            // Invalidar caché de la temporada actual para que se recargue con los nuevos filtros
            const year = y.value;
            const season = document.getElementById('season').value;
            if (year && season) {
                localStorage.removeItem(seasonKey(year, season));
            }
        });
    });

    // Cargar los top 10 automáticamente al abrir la página
    loadTop10();
};

const delay = ms => new Promise(r => setTimeout(r, ms));

function seasonKey(year, season) { return `SEASON_${year}_${season}`; }

function getSeasonCache(key) {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (Date.now() - parsed.timestamp > CACHE_TTL) {
        localStorage.removeItem(key);
        return null;
    }
    parsed.lastUsed = Date.now();
    localStorage.setItem(key, JSON.stringify(parsed));
    return parsed.data;
}

function saveSeasonCache(key, data) {
    localStorage.setItem(key, JSON.stringify({ timestamp: Date.now(), lastUsed: Date.now(), data }));
    cleanupCache();
}

function cleanupCache() {
    const seasons = Object.keys(localStorage)
        .filter(k => k.startsWith('SEASON_'))
        .map(k => ({ key: k, ...JSON.parse(localStorage.getItem(k)) }));
    if (seasons.length <= MAX_SEASONS_CACHED) return;
    seasons.sort((a, b) => a.lastUsed - b.lastUsed)
        .slice(0, seasons.length - MAX_SEASONS_CACHED)
        .forEach(s => localStorage.removeItem(s.key));
}

// Consulta rápida a AniList por un solo MAL ID (ponela ANTES de fetchSeasonMAL)
async function getAniListSeason(malId) {
    const query = `
    query ($idMal: Int) {
      Media(idMal: $idMal, type: ANIME) {
        season
        seasonYear
        startDate {
          year
          month
          day
        }
      }
    }`;

    try {
        const res = await fetch('https://graphql.anilist.co', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, variables: { idMal: malId } })
        });

        if (!res.ok) return null;

        const data = await res.json();
        const media = data.data?.Media;

        if (!media) return null;

        return {
            season: media.season,
            seasonYear: media.seasonYear,
            startYear: media.startDate?.year
        };
    } catch (e) {
        console.error('Error fetching AniList season for MAL ID', malId, e);
        return null;
    }
}

async function fetchSeasonFromAniList(year, season) {
    const allowedFormats = getSelectedTypes().map(t => {
        switch (t) {
            case "TV": return "TV";
            case "ONA": return "ONA";
            case "Movie": return "MOVIE";
            case "OVA": return "OVA";
            case "Special": return "SPECIAL";
            default: return null;
        }
    }).filter(Boolean);

    if (allowedFormats.length === 0) return [];

    const aniSeason = season.toUpperCase(); // WINTER, SPRING, SUMMER, FALL

    const query = `
query ($seasonYear: Int, $season: MediaSeason, $formats: [MediaFormat], $page: Int) {
  Page(page: $page, perPage: 50) {
    pageInfo { hasNextPage }
    media(seasonYear: $seasonYear, season: $season, format_in: $formats, type: ANIME, sort: SCORE_DESC) {
      id
      idMal
      title { 
        english 
        romaji 
        native   # ← AGREGAR ESTO
      }
      averageScore
      format
      episodes
      coverImage { large }
    }
  }
}`;

    let allMedia = [];
    let page = 1;
    let hasNext = true;

    while (hasNext && allMedia.length < 60) {
        try {
            const res = await fetch('https://graphql.anilist.co', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query,
                    variables: { seasonYear: year, season: aniSeason, formats: allowedFormats, page }
                })
            });

            if (!res.ok) break;

            const { data } = await res.json();
            const pageData = data?.Page;

            if (!pageData?.media) break;

            allMedia.push(...pageData.media);
            hasNext = pageData.pageInfo.hasNextPage;
            page++;
            await delay(350); // Rate limit AniList ~90/min, mejor ser conservador
        } catch (e) {
            console.error("Error fetching AniList season", e);
            break;
        }
    }

    // Ordenar por score descendente (aunque ya pedimos sort)
    allMedia.sort((a, b) => (b.averageScore || 0) - (a.averageScore || 0));

    // Mapear a formato compatible con tu código actual (para que renderCard y scores funcionen)
    return allMedia.map(m => ({
    mal_id: m.idMal || null,
    titles: {
        english: m.title?.english ?? null,
        romaji:  m.title?.romaji  ?? null,
        native:  m.title?.native  ?? null
    },
    image: m.coverImage?.large || '',
    score: m.averageScore ? (m.averageScore / 10) : null,
    format: m.format,
    episodes: m.episodes,
    al_id: m.id
}));


}


async function fetchAniListBatch(malIds) {
    const results = {};
    const missingIds = [];

    malIds.forEach(malId => {
        const cacheKey = `AL_MAL_${malId}`;
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
            results[malId] = JSON.parse(cached);
        } else {
            missingIds.push(malId);
        }
    });

    if (missingIds.length === 0) return results;

    const query = `
    query ($ids: [Int]) {
      Page {
        media(idMal_in: $ids, type: ANIME) {
          id
          idMal
          averageScore
        }
      }
    }`;

    const batches = [];
    for (let i = 0; i < missingIds.length; i += BATCH_SIZE) {
        batches.push(missingIds.slice(i, i + BATCH_SIZE));
    }

    for (const batch of batches) {
        const variables = { ids: batch };
        const res = await fetch('https://graphql.anilist.co', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, variables })
        });
        if (!res.ok) continue;
        const data = await res.json();
        const mediaList = data.data.Page?.media || [];
        mediaList.forEach(media => {
            const result = {
                id: media.id,
                score: media.averageScore ? (media.averageScore / 10).toFixed(2) : null
            };
            const cacheKey = `AL_MAL_${media.idMal}`;
            localStorage.setItem(cacheKey, JSON.stringify(result));
            results[media.idMal] = result;
        });
        await delay(1000);
    }

    return results;
}


function getManualScore(malId) {
    const key = `MANUAL_AL_${malId}`;
    const val = localStorage.getItem(key);
    return val ? parseFloat(val).toFixed(2) : null;
}

function saveManualScore(malId, score) {
    const key = `MANUAL_AL_${malId}`;
    localStorage.setItem(key, score);
}

function updateProgress(percent) {
    progressBar.style.width = percent + '%';
    progressText.textContent = Math.round(percent) + '%';
}

function renderSkeletons() {
    grid.innerHTML = '';
    for (let i = 0; i < 10; i++) {
        const d = document.createElement('div');
        d.className = 'skeleton';
        grid.appendChild(d);
    }
}

function renderCard(anime, index) {
    const card = document.createElement('div');
    card.className = 'anime-card';
    const rankClass =
    index === 0 ? 'gold' :
    index === 1 ? 'silver' :
    index === 2 ? 'bronze' :
    'red';

    // Score AniList: automático, manual o N/A
    let alScore = anime.al;
    if (!alScore) {
        alScore = getManualScore(anime.mal_id);
    }
    const hasAlId = anime.al_id !== undefined;
    const finalAlScore = alScore || 'N/A';
   


    // Promedio actualizado con score manual si existe
let malScore = anime.mal != null && !isNaN(parseFloat(anime.mal)) ? parseFloat(anime.mal) : null;
let alFinal  = alScore != null ? parseFloat(alScore) : null;

let avgNum = 0;
let count = 0;
if (malScore != null) { avgNum += malScore; count++; }
if (alFinal  != null) { avgNum += alFinal;  count++; }

const avg = count === 2 ? (avgNum / 2).toFixed(2) :
            count === 1 ? avgNum.toFixed(2) :
            'N/A';

    card.innerHTML = `
    <div class="rank ${rankClass}">#${index + 1}</div>
    <img src="${anime.image}">
    <div class="title">${anime.title}</div>
    <div class="scores">
        MAL: ${anime.mal} |
        AniList: 
        ${alScore 
            ? `<span>${alScore}</span>`
            : hasAlId 
                ? `<span class="al-score" onclick="editAlScore(${anime.mal_id}, this)">${finalAlScore} (editar)</span>`
                : `<span>${finalAlScore}</span>`
        }
        
    </div>
    <div class="bottom">
    <div class="average">⭐ ${avg}</div>
    <div class="links">
        <a href="https://myanimelist.net/anime/${anime.mal_id}" target="_blank">MAL</a>
        ${hasAlId ? `<a href="https://anilist.co/anime/${anime.al_id}" target="_blank">AniList</a>` : ''}
    </div>
</div>
`;

    grid.appendChild(card);
}

function renderPage(page) {
    if (!seasonRanking.length) return;
    const start = (page - 1) * itemsPerPage;
    const end = start + itemsPerPage;
    const pageItems = seasonRanking.slice(start, end);

    grid.innerHTML = '';
    pageItems.forEach((anime, i) => renderCard(anime, start + i));

    // Ocultar flechas si es primera o última página
    document.getElementById('prevPage').style.display = page === 1 ? 'none' : 'block';
    document.getElementById('nextPage').style.display = end >= seasonRanking.length ? 'none' : 'block';
}

// Eventos de flechas
document.getElementById('prevPage').addEventListener('click', () => {
    if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
    }
});
document.getElementById('nextPage').addEventListener('click', () => {
    if (currentPage * itemsPerPage < seasonRanking.length) {
        currentPage++;
        renderPage(currentPage);
    }
});



// Función global para editar score
function editAlScore(malId, element) {
    const current = element.textContent.trim();
    const newText = current.includes('editar') ? '' : current;

    const input = document.createElement('input');
    input.type = 'number';
    input.step = '0.01';
    input.min = '0';
    input.max = '10';
    input.value = newText === 'N/A' || newText === '' ? '' : newText;
    input.className = 'edit-input';

    input.onblur = () => {
        let value = input.value.trim();
        if (value && parseFloat(value) >= 0 && parseFloat(value) <= 10) {
            value = parseFloat(value).toFixed(2);
            saveManualScore(malId, value);
            element.textContent = value;
        } else {
            element.textContent = 'N/A (editar)';
        }
        input.remove();
        // Recalcular todo el top con el nuevo promedio
        loadTop10(); // Recarga para reordenar si cambió el promedio
    };

    input.onkeydown = (e) => {
        if (e.key === 'Enter') input.blur();
        if (e.key === 'Escape') {
            element.textContent = 'N/A (editar)';
            input.remove();
        }
    };

    element.textContent = '';
    element.appendChild(input);
    input.focus();
}

async function loadTop10() {
    const year = parseInt(document.getElementById('year').value);
    const season = document.getElementById('season').value;
    const key = seasonKey(year, season);
    let top10 = getSeasonCache(key);

    if (top10) {
        
        loading.textContent = '';
        progressContainer.style.display = 'none';
        return;
    
    loading.textContent = 'Cargando temporada...';
    progressContainer.style.display = 'block';
    updateProgress(0);
    renderSkeletons();

    let fakeProgress = 0;
    const fakeInterval = setInterval(() => {
        fakeProgress += Math.random() * 4 + 1;
        if (fakeProgress < 85) updateProgress(fakeProgress);
    }, 300);

    // ──────────────────────────────
    // Aquí va el bloque que pegaste (reemplaza lo viejo de malList)
    const aniList = await fetchSeasonFromAniList(year, season);
    updateProgress(30);

    // Obtener datos completos de MAL para los que tengan idMal
    const malIds = aniList.filter(a => a.mal_id).map(a => a.mal_id);
    // Obtener datos completos de MAL para los que tengan idMal (con cache)
updateProgress(30);

// Obtener datos de MAL con cache, retry y límite para evitar 429
const malDataById = {};

// Cache en localStorage (persiste entre recargas)
function getMalCache(id) {
    const raw = localStorage.getItem(`MAL_FULL_${id}`);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (Date.now() - parsed.timestamp > CACHE_TTL) {
        localStorage.removeItem(`MAL_FULL_${id}`);
        return null;
    }
    return parsed.data;
}

function saveMalCache(id, data) {
    localStorage.setItem(`MAL_FULL_${id}`, JSON.stringify({
        timestamp: Date.now(),
        data
    }));
}

// Solo enriquecemos los primeros 15 (los de más score) para no abusar
const malIdsToFetch = aniList
    .filter(a => a.mal_id)
    .map(a => a.mal_id);

for (const id of malIdsToFetch) {
    let malData = getMalCache(id);

    if (!malData) {
        let attempts = 0;
        while (attempts < 3) {
            try {
                const res = await fetch(`https://api.jikan.moe/v4/anime/${id}/full`);
                if (res.status === 429) {
                    console.warn(`429 en MAL ID ${id} → esperando ${5 * (attempts + 1)}s`);
                    await delay(5000 * (attempts + 1));  // backoff exponencial
                    attempts++;
                    continue;
                }
                if (res.ok) {
                    const data = await res.json();
                    malData = data.data;
                    saveMalCache(id, malData);
                    break;
                }
            } catch (e) {
                console.error("Error fetching MAL for", id, e);
                break;
            }
            attempts++;
            await delay(1500);  // delay normal 1.5s
        }
    }

    if (malData) malDataById[id] = malData;
}

    updateProgress(60);

    // Combinar: AniList como base, enriquecer con MAL donde exista
   const enrichedList = aniList.map(ani => {
    const mal = ani.mal_id ? malDataById[ani.mal_id] : null;

    // TÍTULO FINAL (MAL EN > AniList EN > AniList Romaji > Native)
let title = null;

// 1️⃣ MAL inglés
if (mal?.title_english && mal.title_english.trim() !== '') {
    title = mal.title_english.trim();
}
// 2️⃣ MAL fallback (romaji/japonés)
else if (mal?.title && mal.title.trim() !== '') {
    title = mal.title.trim();
}
// 3️⃣ AniList inglés
else if (ani.titles?.english) {
    title = ani.titles.english;
}
// 4️⃣ AniList romaji
else if (ani.titles?.romaji) {
    title = ani.titles.romaji;
}
// 5️⃣ AniList native
else if (ani.titles?.native) {
    title = ani.titles.native;
}
// 6️⃣ último recurso
else {
    title = "Sin título";
}

    // IMAGEN: AniList rey, MAL backup
    let imageUrl = ani.image ||
                   (mal?.images?.jpg?.large_image_url ||
                    'https://via.placeholder.com/300x450?text=Sin+Imagen');

    return {
        mal_id: ani.mal_id,
        title: title.trim() || "Sin título",
        image: imageUrl,
        mal: mal?.score ? parseFloat(mal.score.toFixed(2)) : null,
        al: ani.score ? ani.score.toFixed(2) : null,
        al_id: ani.al_id,
        type: ani.format || 'Unknown'
    };
});
    // ──────────────────────────────

    clearInterval(fakeInterval);
    updateProgress(90);

    // Aquí sigue tu código original de alData (si lo mantenés)
    // const alData = await fetchAniListBatch(enrichedList.map(a => a.mal_id).filter(Boolean));

    const processed = enrichedList.map(ani => {
    const malScoreRaw = ani.mal ?? null;
    let alScoreRaw = ani.al ?? getManualScore(ani.mal_id);

    // Si no hay manual y no hay MAL → usar AniList (ya debería venir)
    if (alScoreRaw == null && ani.al != null) {
        alScoreRaw = ani.al;
    }

    // Números seguros (evitar NaN)
    const malNum = malScoreRaw != null && !isNaN(malScoreRaw) ? parseFloat(malScoreRaw) : null;
    const alNum = alScoreRaw != null && !isNaN(alScoreRaw) ? parseFloat(alScoreRaw) : null;

    // Promedio
    let avgNum = 0;
    let sourcesCount = 0;
    if (malNum != null) { avgNum += malNum; sourcesCount++; }
    if (alNum != null) { avgNum += alNum; sourcesCount++; }
    if (sourcesCount > 0) avgNum /= sourcesCount;

    // Imagen FINAL: AniList es rey
    let finalImage = ani.image || 'https://via.placeholder.com/300x450?text=Sin+Imagen';

    return {
        title: ani.title || "Sin título",  // ya viene de AniList
        image: finalImage,
        mal: malNum != null ? malNum.toFixed(2) : 'N/A',
        al: alNum != null ? alNum.toFixed(2) : 'N/A',
        avg: avgNum.toFixed(2),
        sources: sourcesCount,
        mal_id: ani.mal_id,
        al_id: ani.al_id
    };
});
   
    
    // Filtrar animes que tienen N/A en ambas puntuaciones
    seasonRanking = processed
        .filter(a => a.mal !== 'N/A' || a.al !== 'N/A')
        .sort((a, b) => {
            if (b.avg !== a.avg) return b.avg - a.avg;
            const maxA = Math.max(parseFloat(a.mal || 0), parseFloat(a.al || 0));
            const maxB = Math.max(parseFloat(b.mal || 0), parseFloat(b.al || 0));
            if (maxB !== maxA) return maxB - maxA;
            return a.title.localeCompare(b.title);
        });

    // ¡Aquí estaba el problema!
    currentPage = 1;
    renderPage(currentPage);          // ← Renderizamos SOLO la página actual

    saveSeasonCache(key, seasonRanking);

    startCountdown();
    loading.textContent = '';
    updateProgress(100);
    setTimeout(() => {
        progressContainer.style.display = 'none';
    }, 300);
}
// Retorna milisegundos restantes hasta que expire el caché de esta temporada
function getTimeUntilNextUpdate(year, season) {
    if (!year || !season) return 0;
    
    const key = seasonKey(year, season);
    const raw = localStorage.getItem(key);
    if (!raw) return CACHE_TTL; // si no hay caché → como si acabara de empezar
    
    const parsed = JSON.parse(raw);
    const expiresAt = parsed.timestamp + CACHE_TTL;
    const remaining = expiresAt - Date.now();
    
    return Math.max(0, remaining);
}

// Formatea milisegundos a "Xh Ym Zs" o "menos de 1 minuto", etc.
function formatRemainingTime(ms) {
    if (ms <= 0) return "¡Ahora! (recarga para actualizar)";
    
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours   = Math.floor(minutes / 60);
    
    const s = seconds % 60;
    const m = minutes % 60;
    const h = hours;
    
    if (h > 0) {
        return `${h}h ${m}m ${s}s`;
    } else if (m > 0) {
        return `${m}m ${s}s`;
    } else {
        return `${s}s`;
    }
}

// Inicia y actualiza el countdown cada segundo
let countdownInterval = null;

function startCountdown() {
    const year = document.getElementById('year')?.value;
    const season = document.getElementById('season')?.value;
    
    if (!year || !season) {
        document.getElementById('countdown').textContent = "—";
        return;
    }
    
    const updateCountdown = () => {
        const remainingMs = getTimeUntilNextUpdate(year, season);
        document.getElementById('countdown').textContent = formatRemainingTime(remainingMs);
        
        // Opcional: si llega a 0, podrías cambiar color o texto
        if (remainingMs <= 0) {
            document.getElementById('updateInfo').style.color = '#66ff66';
        }
    };
    
    updateCountdown(); // inmediato
    
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(updateCountdown, 1000);
}
// ────────────────────────────────────────────────
// NUEVO: Sistema de puntajes normal vs porcentual (versión corregida y robusta)

let currentScoreMode = localStorage.getItem('scoreMode') || 'normal';

// Seteamos el valor inicial del select
const scoreModeSelect = document.getElementById('scoreMode');
if (scoreModeSelect) {
    scoreModeSelect.value = currentScoreMode;
}

scoreModeSelect?.addEventListener('change', function() {
    currentScoreMode = this.value;
    localStorage.setItem('scoreMode', currentScoreMode);

    // Actualiza los puntajes de la página actual, sin romper la paginación
    const cards = grid.querySelectorAll('.anime-card');
    cards.forEach((card, i) => {
        const animeIndex = (currentPage - 1) * itemsPerPage + i;
        const anime = seasonRanking[animeIndex];
        if (!anime) return;

        const malTextNode = card.querySelector('.scores').childNodes[0];
        const alElement = card.querySelector('.scores span');
        const avgElement = card.querySelector('.average');

        const malVal = anime.mal !== 'N/A' ? parseFloat(anime.mal) : null;
        const alVal  = anime.al  !== 'N/A' ? parseFloat(anime.al)  : null;

        let avgNum = 0, sources = 0;
        if (malVal !== null) { avgNum += malVal; sources++; }
        if (alVal  !== null) { avgNum += alVal; sources++; }
        const avgRaw = sources > 0 ? avgNum / sources : null;

        const format = (num) => {
            if (num === null) return 'N/A';
            return currentScoreMode === 'percent' ? (num*10).toFixed(2)+'%' : num.toFixed(2);
        };

        if (malTextNode) malTextNode.textContent = `MAL: ${format(malVal)} | AniList: `;
        if (alElement) alElement.textContent = alVal !== null ? format(alVal) : 'N/A (editar)';
        if (avgElement) avgElement.textContent = `⭐ ${format(avgRaw)}`;
    });
});


// Override seguro de renderCard (se define DESPUÉS de la función original)
function updateScoreModeDisplay() {
    const cards = document.querySelectorAll('.anime-card');
    cards.forEach((card, i) => {
        const anime = seasonRanking[(currentPage-1)*itemsPerPage + i];
        if (!anime) return;

        const malTextNode = card.querySelector('.scores').childNodes[0];
        const alElement = card.querySelector('.scores span');
        const avgElement = card.querySelector('.average');

        const malVal = anime.mal !== 'N/A' ? parseFloat(anime.mal) : null;
        const alVal  = anime.al  !== 'N/A' ? parseFloat(anime.al)  : null;

        let avgNum = 0, sources = 0;
        if (malVal !== null) { avgNum += malVal; sources++; }
        if (alVal  !== null) { avgNum += alVal;  sources++; }
        const avgRaw = sources > 0 ? avgNum / sources : null;

        const format = (num) => {
            if (num === null) return 'N/A';
            return currentScoreMode === 'percent' ? (num*10).toFixed(2)+'%' : num.toFixed(2);
        };

        if (malTextNode) malTextNode.textContent = `MAL: ${format(malVal)} | AniList: `;
        if (alElement) alElement.textContent = alVal !== null ? format(alVal) : 'N/A (editar)';
        if (avgElement) avgElement.textContent = `⭐ ${format(avgRaw)}`;
    });
}

// FIN NUEVO (versión corregida)
// ────────────────────────────────────────────────
function getSelectedTypes() {
    const types = [];
    if (document.getElementById('type-tv').checked)     types.push("TV");
    if (document.getElementById('type-ona').checked)    types.push("ONA");
    if (document.getElementById('type-movie').checked)  types.push("Movie");
    if (document.getElementById('type-ova').checked)    types.push("OVA");
    if (document.getElementById('type-special').checked) types.push("Special");
    return types;
}

</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c30e57fddaff3fe',t:'MTc2OTI3MjAzOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>