<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Top 10 Animes por Temporada (MAL + AniList)</title>
<style>

body {
    font-family: Arial, sans-serif;
    background:#000;
    color:#fff;
    text-align:center;
    margin:0;
    padding:20px;
}
h1 {
    color:#cc0000;
    font-size:2.6em;
    text-shadow:0 0 10px rgba(204,0,0,.5);
}
.controls { margin:30px auto; }
select, button {
    padding:12px;
    font-size:1.05em;
    margin:10px;
    border-radius:8px;
    border:2px solid #cc0000;
    background:#111;
    color:#fff;
}
button {
    cursor:pointer;
    background:linear-gradient(45deg,#cc0000,#ff3333);
}
button:hover { transform:scale(1.05); }
.grid {
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:25px;
    max-width:1400px;
    margin:40px auto;
}
.anime-card {
    background:#111;
    border-radius:15px;
    padding:15px;
    box-shadow:
        0 0 15px rgba(204,0,0,.25),
        0 10px 25px rgba(0,0,0,.6);
    transition:.3s;

    display: flex;
    flex-direction: column;
    animation: fadeUp .4s ease;
}


.anime-card:hover {
    transform: translateY(-6px) scale(1.02);
}
.anime-card img {
    width:100%;
    border-radius:12px;
    border:2px solid #cc0000;
    height: 300px;
    object-fit: cover;
}
.rank {
    font-size:2.1em;
    font-weight:bold;
}
.rank.gold {
    color: gold;
    text-shadow: 0 0 8px gold;
}

.rank.silver {
    color: silver;
    text-shadow: 0 0 6px silver;
}

.rank.bronze {
    color: #cd7f32;
    text-shadow: 0 0 6px #cd7f32;
}

.rank.red { color:#cc0000; }
.title {
    font-weight: bold;
    font-size: 1.05em;
    margin: 5px 0;

    line-height: 1.2em;

    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 4;   /* üî• m√°ximo 5 l√≠neas */

    overflow: hidden;

    min-height: 6em;        /* üî• 5 l√≠neas √ó 1.2em */
}
.scores {
    font-size: 0.85em;
    color: #aaa;
    margin: 3x 0;

    min-height: 2.4em; /* üî• clave */
}

.average {
    font-size:1.6em;
    color:#ff0;
    text-shadow:0 0 8px rgba(255,255,0,.6);
    margin-bottom: 14px; /* espacio hacia los links */
}
.links a {
    color:#ff6666;
    margin:0 8px;
    text-decoration:none;
}
.links a:hover { text-decoration:underline; }

/* Edici√≥n manual */
.al-score {
    cursor: pointer;
    color: #ff6666;
    font-weight: bold;
}
.al-score:hover {
    text-decoration: underline;
}
.edit-input {
    width: 60px;
    padding: 4px;
    background: #222;
    color: #fff;
    border: 1px solid #cc0000;
    border-radius: 4px;
    text-align: center;
}

/* Barra de progreso */
.progress-container {
    width: 60%;
    max-width: 800px;
    margin: 30px auto;
    background: #222;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(204,0,0,.6);
    display: none;
}
.progress-bar {
    width: 0%;
    height: 30px;
    background: linear-gradient(90deg, #cc0000, #ff4444);
    border-radius: 10px;
    transition: width 0.4s ease;
    position: relative;
}
.progress-text {
    position: absolute;
    width: 100%;
    text-align: center;
    line-height: 30px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 3px black;
}

.skeleton {
    background:#111;
    border-radius:15px;
    padding:15px;
    box-shadow:
        0 0 15px rgba(204,0,0,.25),
        0 10px 25px rgba(0,0,0,.6);

    height: 520px; /* üî• mismo alto que una card real */

    background: linear-gradient(90deg, #111, #222, #111);
    background-size: 200% 100%;
    animation: pulse 1.5s infinite;
}
@keyframes pulse {
    0% { background-position: 0% }
    100% { background-position: 200% }
}
@media(max-width:1200px){ .grid{grid-template-columns:repeat(3,1fr);} }
@media(max-width:800px){ 
    .grid{grid-template-columns:repeat(2,1fr);} 
    .progress-container { width: 90%; }
}
@keyframes fadeUp {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
.bottom {
    margin-top: auto;
}
/* Ajustes para que el dropdown quede con la misma altura y estilo */
#scoreMode {
    padding: 8px 12px;                /* altura similar a checkboxes */
    font-size: 1.1em;                 /* mismo tama√±o de letra que los labels */
    border-radius: 8px;
    border: 2px solid #cc0000;
    background: #111;
    color: #fff;
    min-height: 38px;                 /* altura aproximada para alinear con labels */
    cursor: pointer;
}

#scoreMode option {
    background: #111;
    color: #fff;
}

/* Opcional: hover en el dropdown para que coincida con el bot√≥n */
#scoreMode:hover {
    border-color: #ff4444;
    box-shadow: 0 0 8px rgba(204,0,0,0.4);
}

.pagination button {
    padding: 10px 18px;
    font-size: 1.1em;
    border: 2px solid #cc0000;
    background: #111;
    color: #fff;
    border-radius: 8px;
    cursor: pointer;
    transition: all .2s;
}

.pagination button:hover:not(:disabled) {
    background: #cc0000;
    transform: scale(1.08);
}

.pagination button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.pagination span {
    min-width: 140px;
    text-align: center;
}
</style>
</head>
<body>
<h1>Top 10 Animes por Temporada</h1>
<div id="updateInfo" style="margin: 15px auto; font-size: 1.1em; color: #ff9999; min-height: 1.5em;">
    Pr√≥xima actualizaci√≥n en: <span id="countdown">--:--:--</span>
</div>
<div id="loading" class="loading">Seleccion√° temporada y a√±o</div>
<div class="controls">
    <select id="year"></select>
    <select id="season">
        <option value="winter">Winter</option>
        <option value="spring">Spring</option>
        <option value="summer">Summer</option>
        <option value="fall">Fall</option>
    </select>

    <!-- Checkboxes + dropdown juntos -->
    <div style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; margin: 15px auto;">
        <div class="type-filters" style="font-size: 1.1em; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <label><input type="checkbox" id="type-tv" checked disabled> TV</label>
            <label><input type="checkbox" id="type-ona"> ONA</label>
            <label><input type="checkbox" id="type-movie"> Movie</label>
            <label><input type="checkbox" id="type-ova"> OVA</label>
            <label><input type="checkbox" id="type-special"> Special</label>
        </div>

        <!-- Dropdown al lado -->
        <div style="display: flex; align-items: center; gap: 10px; white-space: nowrap;">
            <label for="scoreMode" style="font-size: 1.1em;">Mostrar puntajes como:</label>
            <select id="scoreMode">
                <option value="normal">Del 1 al 10</option>
                <option value="percent">Porcentual</option>
            </select>
        </div>
    </div>

    <button onclick="loadTop10()">Buscar</button>
</div>

<div id="progressContainer" class="progress-container">
    <div id="progressBar" class="progress-bar">
        <div id="progressText" class="progress-text">0%</div>
    </div>
</div>


<div id="grid" class="grid"></div>
<div id="pagination" class="pagination" style="margin: 40px auto; font-size: 1.2em; display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap;">
    <button id="prevPage" onclick="changePage(-1)" disabled>Anterior</button>
    <span id="pageInfo">P√°gina 1 de 1</span>
    <button id="nextPage" onclick="changePage(1)" disabled>Siguiente</button>
</div>

<script>
const CACHE_TTL = 4 * 60 * 60 * 1000;     // 4 horas
const MAX_SEASONS_CACHED = 25;
const BATCH_SIZE = 15;

const grid = document.getElementById('grid');
const loading = document.getElementById('loading');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

let currentPage = 1;
const ITEMS_PER_PAGE = 10;
let fullRanking = []; // Aqu√≠ guardaremos TODOS los animes ordenados

window.onload = () => {
    const y = document.getElementById('year');
    const currentYear = new Date().getFullYear();
    
    // Generamos opciones desde el a√±o actual +2 hasta 1990
    for (let i = currentYear + 2; i >= 1990; i--) {
        const o = document.createElement('option');
        o.value = i;
        o.textContent = i;
        y.appendChild(o);
    }

    // Restaurar a√±o guardado
    const savedYear = localStorage.getItem('selectedYear');
    if (savedYear && y.querySelector(`option[value="${savedYear}"]`)) {
        y.value = savedYear;
    } else {
        // Fallback: a√±o actual (o pr√≥ximo si ya estamos en Q4, pero por simplicidad usamos current)
        y.value = currentYear;
    }

    // Restaurar temporada
    const savedSeason = localStorage.getItem('selectedSeason');
    if (savedSeason) {
        const seasonSelect = document.getElementById('season');
        if (seasonSelect.querySelector(`option[value="${savedSeason}"]`)) {
            seasonSelect.value = savedSeason;
        }
    }

    // Restaurar tipos (ONA, Movie, etc.)
    const savedTypes = JSON.parse(localStorage.getItem('selectedTypes') || '[]');
    document.getElementById('type-ona').checked = savedTypes.includes("ONA");
    document.getElementById('type-movie').checked = savedTypes.includes("Movie");
    document.getElementById('type-ova').checked = savedTypes.includes("OVA");
    document.getElementById('type-special').checked = savedTypes.includes("Special");

    // Iniciar countdown
    startCountdown();

    // Guardar cambios en localStorage
    y.addEventListener('change', () => {
        localStorage.setItem('selectedYear', y.value);
        startCountdown();
    });

    document.getElementById('season').addEventListener('change', () => {
        localStorage.setItem('selectedSeason', document.getElementById('season').value);
        startCountdown();
    });

    // Guardar cambios en checkboxes y invalidar cach√© si cambia
    const checkboxes = document.querySelectorAll('.type-filters input[type="checkbox"]:not([disabled])');
    checkboxes.forEach(chk => {
        chk.addEventListener('change', () => {
            const selectedTypes = [];
            if (document.getElementById('type-ona').checked) selectedTypes.push("ONA");
            if (document.getElementById('type-movie').checked) selectedTypes.push("Movie");
            if (document.getElementById('type-ova').checked) selectedTypes.push("OVA");
            if (document.getElementById('type-special').checked) selectedTypes.push("Special");
            localStorage.setItem('selectedTypes', JSON.stringify(selectedTypes));

            // Invalidar cach√© de la temporada actual para que se recargue con los nuevos filtros
            const year = y.value;
            const season = document.getElementById('season').value;
            if (year && season) {
                localStorage.removeItem(seasonKey(year, season));
            }
        });
    });

    // Cargar los top 10 autom√°ticamente al abrir la p√°gina
    loadTop10();
};

const delay = ms => new Promise(r => setTimeout(r, ms));

function seasonKey(year, season) { return `SEASON_${year}_${season}`; }

function getSeasonCache(key) {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (Date.now() - parsed.timestamp > CACHE_TTL) {
        localStorage.removeItem(key);
        return null;
    }
    parsed.lastUsed = Date.now();
    localStorage.setItem(key, JSON.stringify(parsed));
    return parsed.data;
}

function saveSeasonCache(key, data) {
    localStorage.setItem(key, JSON.stringify({ timestamp: Date.now(), lastUsed: Date.now(), data }));
    cleanupCache();
}

function cleanupCache() {
    const seasons = Object.keys(localStorage)
        .filter(k => k.startsWith('SEASON_'))
        .map(k => ({ key: k, ...JSON.parse(localStorage.getItem(k)) }));
    if (seasons.length <= MAX_SEASONS_CACHED) return;
    seasons.sort((a, b) => a.lastUsed - b.lastUsed)
        .slice(0, seasons.length - MAX_SEASONS_CACHED)
        .forEach(s => localStorage.removeItem(s.key));
}

// Consulta r√°pida a AniList por un solo MAL ID (ponela ANTES de fetchSeasonMAL)
async function getAniListSeason(malId) {
    const query = `
    query ($idMal: Int) {
      Media(idMal: $idMal, type: ANIME) {
        season
        seasonYear
        startDate {
          year
          month
          day
        }
      }
    }`;

    try {
        const res = await fetch('https://graphql.anilist.co', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, variables: { idMal: malId } })
        });

        if (!res.ok) return null;

        const data = await res.json();
        const media = data.data?.Media;

        if (!media) return null;

        return {
            season: media.season,
            seasonYear: media.seasonYear,
            startYear: media.startDate?.year
        };
    } catch (e) {
        console.error('Error fetching AniList season for MAL ID', malId, e);
        return null;
    }
}

async function fetchSeasonFromAniList(year, season) {
    const allowedFormats = getSelectedTypes().map(t => {
        switch (t) {
            case "TV": return "TV";
            case "ONA": return "ONA";
            case "Movie": return "MOVIE";
            case "OVA": return "OVA";
            case "Special": return "SPECIAL";
            default: return null;
        }
    }).filter(Boolean);

    if (allowedFormats.length === 0) return [];

    const aniSeason = season.toUpperCase(); // WINTER, SPRING, SUMMER, FALL

    const query = `
query ($seasonYear: Int, $season: MediaSeason, $formats: [MediaFormat], $page: Int) {
  Page(page: $page, perPage: 50) {
    pageInfo { hasNextPage }
    media(seasonYear: $seasonYear, season: $season, format_in: $formats, type: ANIME, sort: SCORE_DESC) {
      id
      idMal
      title { 
        english 
        romaji 
        native   # ‚Üê AGREGAR ESTO
      }
      averageScore
      format
      episodes
      coverImage { large }
    }
  }
}`;

    let allMedia = [];
    let page = 1;
    let hasNext = true;

    while (hasNext && allMedia.length < 60) {
        try {
            const res = await fetch('https://graphql.anilist.co', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query,
                    variables: { seasonYear: year, season: aniSeason, formats: allowedFormats, page }
                })
            });

            if (!res.ok) break;

            const { data } = await res.json();
            const pageData = data?.Page;

            if (!pageData?.media) break;

            allMedia.push(...pageData.media);
            hasNext = pageData.pageInfo.hasNextPage;
            page++;
            await delay(350); // Rate limit AniList ~90/min, mejor ser conservador
        } catch (e) {
            console.error("Error fetching AniList season", e);
            break;
        }
    }

    // Ordenar por score descendente (aunque ya pedimos sort)
    allMedia.sort((a, b) => (b.averageScore || 0) - (a.averageScore || 0));

    // Mapear a formato compatible con tu c√≥digo actual (para que renderCard y scores funcionen)
    return allMedia.slice(0, 40).map(m => ({
    mal_id: m.idMal || null,
    titles: {
        english: m.title?.english ?? null,
        romaji:  m.title?.romaji  ?? null,
        native:  m.title?.native  ?? null
    },
    image: m.coverImage?.large || '',
    score: m.averageScore ? (m.averageScore / 10) : null,
    format: m.format,
    episodes: m.episodes,
    al_id: m.id
}));

}


async function fetchAniListBatch(malIds) {
    const results = {};
    const missingIds = [];

    malIds.forEach(malId => {
        const cacheKey = `AL_MAL_${malId}`;
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
            results[malId] = JSON.parse(cached);
        } else {
            missingIds.push(malId);
        }
    });

    if (missingIds.length === 0) return results;

    const query = `
    query ($ids: [Int]) {
      Page {
        media(idMal_in: $ids, type: ANIME) {
          id
          idMal
          averageScore
        }
      }
    }`;

    const batches = [];
    for (let i = 0; i < missingIds.length; i += BATCH_SIZE) {
        batches.push(missingIds.slice(i, i + BATCH_SIZE));
    }

    for (const batch of batches) {
        const variables = { ids: batch };
        const res = await fetch('https://graphql.anilist.co', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, variables })
        });
        if (!res.ok) continue;
        const data = await res.json();
        const mediaList = data.data.Page?.media || [];
        mediaList.forEach(media => {
            const result = {
                id: media.id,
                score: media.averageScore ? (media.averageScore / 10).toFixed(2) : null
            };
            const cacheKey = `AL_MAL_${media.idMal}`;
            localStorage.setItem(cacheKey, JSON.stringify(result));
            results[media.idMal] = result;
        });
        await delay(1000);
    }

    return results;
}


function getManualScore(malId) {
    const key = `MANUAL_AL_${malId}`;
    const val = localStorage.getItem(key);
    return val ? parseFloat(val).toFixed(2) : null;
}

function saveManualScore(malId, score) {
    const key = `MANUAL_AL_${malId}`;
    localStorage.setItem(key, score);
}

function updateProgress(percent) {
    progressBar.style.width = percent + '%';
    progressText.textContent = Math.round(percent) + '%';
}

function renderSkeletons() {
    grid.innerHTML = '';
    for (let i = 0; i < 10; i++) {
        const d = document.createElement('div');
        d.className = 'skeleton';
        grid.appendChild(d);
    }
}

function renderCard(anime, index) {
    const card = document.createElement('div');
    card.className = 'anime-card';
    const rankClass =
    index === 0 ? 'gold' :
    index === 1 ? 'silver' :
    index === 2 ? 'bronze' :
    'red';

    // Score AniList: autom√°tico, manual o N/A
    let alScore = anime.al;
    if (!alScore) {
        alScore = getManualScore(anime.mal_id);
    }
    const hasAlId = anime.al_id !== undefined;
    const finalAlScore = alScore || 'N/A';
   


    // Promedio actualizado con score manual si existe
let malScore = anime.mal != null && !isNaN(parseFloat(anime.mal)) ? parseFloat(anime.mal) : null;
let alFinal  = alScore != null ? parseFloat(alScore) : null;

let avgNum = 0;
let count = 0;
if (malScore != null) { avgNum += malScore; count++; }
if (alFinal  != null) { avgNum += alFinal;  count++; }

const avg = count === 2 ? (avgNum / 2).toFixed(2) :
            count === 1 ? avgNum.toFixed(2) :
            'N/A';

    card.innerHTML = `
    <div class="rank ${rankClass}">#${index + 1}</div>
    <img src="${anime.image}">
    <div class="title">${anime.title}</div>
    <div class="scores">
        MAL: ${anime.mal} |
        AniList: 
        ${alScore 
            ? `<span>${alScore}</span>`
            : hasAlId 
                ? `<span class="al-score" onclick="editAlScore(${anime.mal_id}, this)">${finalAlScore} (editar)</span>`
                : `<span>${finalAlScore}</span>`
        }
        
    </div>
    <div class="bottom">
    <div class="average">‚≠ê ${avg}</div>
    <div class="links">
        <a href="https://myanimelist.net/anime/${anime.mal_id}" target="_blank">MAL</a>
        ${hasAlId ? `<a href="https://anilist.co/anime/${anime.al_id}" target="_blank">AniList</a>` : ''}
    </div>
</div>
`;

    grid.appendChild(card);
}

// Funci√≥n global para editar score
function editAlScore(malId, element) {
    const current = element.textContent.trim();
    const newText = current.includes('editar') ? '' : current;

    const input = document.createElement('input');
    input.type = 'number';
    input.step = '0.01';
    input.min = '0';
    input.max = '10';
    input.value = newText === 'N/A' || newText === '' ? '' : newText;
    input.className = 'edit-input';

    input.onblur = () => {
        let value = input.value.trim();
        if (value && parseFloat(value) >= 0 && parseFloat(value) <= 10) {
            value = parseFloat(value).toFixed(2);
            saveManualScore(malId, value);
            element.textContent = value;
        } else {
            element.textContent = 'N/A (editar)';
        }
        input.remove();
        // Recalcular todo el top con el nuevo promedio
        loadTop10(); // Recarga para reordenar si cambi√≥ el promedio
    };

    input.onkeydown = (e) => {
        if (e.key === 'Enter') input.blur();
        if (e.key === 'Escape') {
            element.textContent = 'N/A (editar)';
            input.remove();
        }
    };

    element.textContent = '';
    element.appendChild(input);
    input.focus();
}

async function loadTop10() {
    const year = parseInt(document.getElementById('year').value);
    const season = document.getElementById('season').value;
    const key = seasonKey(year, season);

    // Validaci√≥n b√°sica
    if (!year || isNaN(year) || !season) {
        loading.textContent = 'Por favor selecciona un a√±o y temporada v√°lidos';
        progressContainer.style.display = 'none';
        return;
    }

    let fullRanking = getSeasonCache(key);

    if (fullRanking && fullRanking.length > 0) {
        currentPage = 1;
        renderPage();
        loading.textContent = '';
        progressContainer.style.display = 'none';
        startCountdown();
        return;
    }

    loading.textContent = 'Cargando temporada...';
    progressContainer.style.display = 'block';
    updateProgress(0);
    renderSkeletons();

    let fakeProgress = 0;
    const fakeInterval = setInterval(() => {
        fakeProgress += Math.random() * 4 + 1;
        if (fakeProgress < 85) updateProgress(fakeProgress);
    }, 300);

    // Cargar datos de AniList
    const aniList = await fetchSeasonFromAniList(year, season);
    updateProgress(30);

    // Preparar MAL
    const malDataById = {};
    const malIdsToFetch = aniList
        .filter(a => a.mal_id)
        .map(a => a.mal_id)
        .slice(0, 15);

    for (const id of malIdsToFetch) {
        let malData = getMalCache(id);
        if (!malData) {
            let attempts = 0;
            while (attempts < 3) {
                try {
                    const res = await fetch(`https://api.jikan.moe/v4/anime/${id}/full`);
                    if (res.status === 429) {
                        await delay(5000 * (attempts + 1));
                        attempts++;
                        continue;
                    }
                    if (res.ok) {
                        const data = await res.json();
                        malData = data.data;
                        saveMalCache(id, malData);
                        break;
                    }
                } catch (e) {
                    console.error("Error fetching MAL", id, e);
                    break;
                }
                attempts++;
                await delay(1500);
            }
        }
        if (malData) malDataById[id] = malData;
    }

    updateProgress(60);

    // Combinar AniList + MAL
    const enrichedList = aniList.map(ani => {
        const mal = ani.mal_id ? malDataById[ani.mal_id] : null;

        let title = mal?.title_english?.trim() || mal?.title?.trim() ||
                    ani.titles?.english || ani.titles?.romaji || ani.titles?.native || "Sin t√≠tulo";

        let imageUrl = ani.image ||
                       mal?.images?.jpg?.large_image_url ||
                       'https://via.placeholder.com/300x450?text=Sin+Imagen';

        return {
            mal_id: ani.mal_id,
            title: title.trim(),
            image: imageUrl,
            mal: mal?.score ? parseFloat(mal.score.toFixed(2)) : null,
            al: ani.score ? ani.score.toFixed(2) : null,
            al_id: ani.al_id,
            type: ani.format || 'Unknown'
        };
    });

    clearInterval(fakeInterval);
    updateProgress(90);

    // Procesar promedios
    const processed = enrichedList.map(ani => {
        const malNum = ani.mal != null ? ani.mal : null;
        const alNum = ani.al ?? parseFloat(getManualScore(ani.mal_id)) || null;

        let avgNum = 0;
        let count = 0;
        if (malNum != null) { avgNum += malNum; count++; }
        if (alNum != null) { avgNum += alNum; count++; }
        const avg = count > 0 ? (avgNum / count).toFixed(2) : 'N/A';

        return {
            title: ani.title || "Sin t√≠tulo",
            image: ani.image,
            mal: malNum?.toFixed(2) ?? 'N/A',
            al: alNum?.toFixed(2) ?? 'N/A',
            avg,
            mal_id: ani.mal_id,
            al_id: ani.al_id
        };
    });

    // Ordenar y guardar
    fullRanking = processed.sort((a, b) => {
        const avgA = parseFloat(a.avg) || 0;
        const avgB = parseFloat(b.avg) || 0;
        if (avgB !== avgA) return avgB - avgA;
        return a.title.localeCompare(b.title);
    });

    saveSeasonCache(key, fullRanking);

    // Renderizar
    currentPage = 1;
    renderPage();

    startCountdown();
    loading.textContent = '';
    updateProgress(100);
    setTimeout(() => progressContainer.style.display = 'none', 300);
}
// Renderiza SOLO la p√°gina actual
function renderPage() {
    grid.innerHTML = '';

    const totalItems = fullRanking.length;
    const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE) || 1; // ‚Üê Evita divisi√≥n por 0

    // Si no hay animes, mostramos mensaje
    if (totalItems === 0) {
        grid.innerHTML = '<div style="font-size: 1.5em; color: #ff6666; padding: 40px;">No se encontraron animes para esta temporada con los filtros seleccionados.</div>';
        document.getElementById('pageInfo').textContent = 'P√°gina 1 de 1 (0 animes)';
        document.getElementById('prevPage').disabled = true;
        document.getElementById('nextPage').disabled = true;
        return;
    }

    const start = (currentPage - 1) * ITEMS_PER_PAGE;
    const end = Math.min(start + ITEMS_PER_PAGE, totalItems);
    const pageItems = fullRanking.slice(start, end);

    pageItems.forEach((anime, idx) => {
        const globalIndex = start + idx;
        renderCard(anime, globalIndex);
    });

    document.getElementById('pageInfo').textContent = 
        `P√°gina ${currentPage} de ${totalPages} (${totalItems} animes)`;

    const prevBtn = document.getElementById('prevPage');
    const nextBtn = document.getElementById('nextPage');

    prevBtn.disabled = currentPage === 1;
    nextBtn.disabled = currentPage >= totalPages;
}

// Cambia de p√°gina
function changePage(delta) {
    currentPage += delta;
    if (currentPage < 1) currentPage = 1;
    if (currentPage > Math.ceil(fullRanking.length / ITEMS_PER_PAGE)) {
        currentPage = Math.ceil(fullRanking.length / ITEMS_PER_PAGE);
    }
    renderPage();
}
// Retorna milisegundos restantes hasta que expire el cach√© de esta temporada
function getTimeUntilNextUpdate(year, season) {
    if (!year || !season) return 0;
    
    const key = seasonKey(year, season);
    const raw = localStorage.getItem(key);
    if (!raw) return CACHE_TTL; // si no hay cach√© ‚Üí como si acabara de empezar
    
    const parsed = JSON.parse(raw);
    const expiresAt = parsed.timestamp + CACHE_TTL;
    const remaining = expiresAt - Date.now();
    
    return Math.max(0, remaining);
}

// Formatea milisegundos a "Xh Ym Zs" o "menos de 1 minuto", etc.
function formatRemainingTime(ms) {
    if (ms <= 0) return "¬°Ahora! (recarga para actualizar)";
    
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours   = Math.floor(minutes / 60);
    
    const s = seconds % 60;
    const m = minutes % 60;
    const h = hours;
    
    if (h > 0) {
        return `${h}h ${m}m ${s}s`;
    } else if (m > 0) {
        return `${m}m ${s}s`;
    } else {
        return `${s}s`;
    }
}

// Inicia y actualiza el countdown cada segundo
let countdownInterval = null;

function startCountdown() {
    const year = document.getElementById('year')?.value;
    const season = document.getElementById('season')?.value;
    
    if (!year || !season) {
        document.getElementById('countdown').textContent = "‚Äî";
        return;
    }
    
    const updateCountdown = () => {
        const remainingMs = getTimeUntilNextUpdate(year, season);
        document.getElementById('countdown').textContent = formatRemainingTime(remainingMs);
        
        // Opcional: si llega a 0, podr√≠as cambiar color o texto
        if (remainingMs <= 0) {
            document.getElementById('updateInfo').style.color = '#66ff66';
        }
    };
    
    updateCountdown(); // inmediato
    
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(updateCountdown, 1000);
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// NUEVO: Sistema de puntajes normal vs porcentual (versi√≥n corregida y robusta)

let currentScoreMode = localStorage.getItem('scoreMode') || 'normal';

// Seteamos el valor inicial del select
const scoreModeSelect = document.getElementById('scoreMode');
if (scoreModeSelect) {
    scoreModeSelect.value = currentScoreMode;
}

scoreModeSelect?.addEventListener('change', function() {
    currentScoreMode = this.value;
    localStorage.setItem('scoreMode', currentScoreMode);
    
    // Si hay cards cargadas (no skeletons), re-renderizamos desde cach√©
    if (grid.children.length > 0 && !grid.querySelector('.skeleton')) {
        const year = parseInt(document.getElementById('year')?.value);
        const season = document.getElementById('season')?.value;
        if (year && season) {
            const cached = getSeasonCache(seasonKey(year, season));
            if (cached) {
                grid.innerHTML = '';
                cached.forEach((anime, i) => renderCard(anime, i));
            }
        }
    }
});

// Override seguro de renderCard (se define DESPU√âS de la funci√≥n original)
// Override seguro de renderCard
const originalRenderCard = renderCard;
renderCard = function(anime, index) {
    originalRenderCard(anime, index);

    const card = grid.lastElementChild;
    if (!card) return;

    const malTextNode = card.querySelector('.scores').childNodes[0]; // "MAL: xx.xx | "
    const alElement   = card.querySelector('.scores span');
    const avgElement  = card.querySelector('.average');

    // Valores seguros (igual que en processed y renderCard original)
    // Valores seguros
const malVal = anime.mal !== 'N/A' && !isNaN(parseFloat(anime.mal)) ? parseFloat(anime.mal) : null;
const alVal  = anime.al  !== 'N/A' && !isNaN(parseFloat(anime.al))  ? parseFloat(anime.al)  : null;

// Promedio
let avgNum = 0;
let sources = 0;
if (malVal !== null) { avgNum += malVal; sources++; }
if (alVal  !== null) { avgNum += alVal;  sources++; }

const avgRaw = sources === 2 ? avgNum / 2 :
               sources === 1 ? avgNum :
               null;

// Formateador (ahora maneja N/A correctamente)
const format = (num) => {
    if (num === null) return 'N/A';
    const formatted = currentScoreMode === 'percent'
        ? (num * 10).toFixed(2) + '%'
        : num.toFixed(2);
    return formatted;
};

// Actualizar textos
if (malTextNode) {
    malTextNode.textContent = `MAL: ${format(malVal)} | AniList: `;
}
if (alElement) {
    alElement.textContent = format(alVal);
    if (alElement.classList.contains('al-score') && alVal === null) {
        alElement.textContent = 'N/A (editar)';
    }
}
if (avgElement) {
    avgElement.textContent = `‚≠ê ${format(avgRaw)}`;
}
};
// FIN NUEVO (versi√≥n corregida)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getSelectedTypes() {
    const types = [];
    if (document.getElementById('type-tv').checked)     types.push("TV");
    if (document.getElementById('type-ona').checked)    types.push("ONA");
    if (document.getElementById('type-movie').checked)  types.push("Movie");
    if (document.getElementById('type-ova').checked)    types.push("OVA");
    if (document.getElementById('type-special').checked) types.push("Special");
    return types;
}

</script>
</body>
</html>
