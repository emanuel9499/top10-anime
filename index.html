<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Top 10 Animes por Temporada (MAL + AniList)</title>
<style>

body {
    font-family: Arial, sans-serif;
    background:#000;
    color:#fff;
    text-align:center;
    margin:0;
    padding:20px;
}
h1 {
    color:#cc0000;
    font-size:2.6em;
    text-shadow:0 0 10px rgba(204,0,0,.5);
}
.controls { margin:30px auto; }
select, button {
    padding:12px;
    font-size:1.05em;
    margin:10px;
    border-radius:8px;
    border:2px solid #cc0000;
    background:#111;
    color:#fff;
}
button {
    cursor:pointer;
    background:linear-gradient(45deg,#cc0000,#ff3333);
}
button:hover { transform:scale(1.05); }
.grid {
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:25px;
    max-width:1400px;
    margin:40px auto;
}
.anime-card {
    background:#111;
    border-radius:15px;
    padding:15px;
    box-shadow:
        0 0 15px rgba(204,0,0,.25),
        0 10px 25px rgba(0,0,0,.6);
    transition:.3s;

    display: flex;
    flex-direction: column;
    animation: fadeUp .4s ease;
}


.anime-card:hover {
    transform: translateY(-6px) scale(1.02);
}
.anime-card img {
    width:100%;
    border-radius:12px;
    border:2px solid #cc0000;
    height: 300px;
    object-fit: cover;
}
.rank {
    font-size:2.1em;
    font-weight:bold;
}
.rank.gold {
    color: gold;
    text-shadow: 0 0 8px gold;
}

.rank.silver {
    color: silver;
    text-shadow: 0 0 6px silver;
}

.rank.bronze {
    color: #cd7f32;
    text-shadow: 0 0 6px #cd7f32;
}

.rank.red { color:#cc0000; }
.title {
    font-weight: bold;
    font-size: 1.05em;
    margin: 5px 0;

    line-height: 1.2em;

    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 4;   /* üî• m√°ximo 5 l√≠neas */

    overflow: hidden;

    min-height: 6em;        /* üî• 5 l√≠neas √ó 1.2em */
}
.scores {
    font-size: 0.85em;
    color: #aaa;
    margin: 3x 0;

    min-height: 2.4em; /* üî• clave */
}

.average {
    font-size:1.6em;
    color:#ff0;
    text-shadow:0 0 8px rgba(255,255,0,.6);
    margin-bottom: 14px; /* espacio hacia los links */
}
.links a {
    color:#ff6666;
    margin:0 8px;
    text-decoration:none;
}
.links a:hover { text-decoration:underline; }

/* Edici√≥n manual */
.al-score {
    cursor: pointer;
    color: #ff6666;
    font-weight: bold;
}
.al-score:hover {
    text-decoration: underline;
}
.edit-input {
    width: 60px;
    padding: 4px;
    background: #222;
    color: #fff;
    border: 1px solid #cc0000;
    border-radius: 4px;
    text-align: center;
}

/* Barra de progreso */
.progress-container {
    width: 60%;
    max-width: 800px;
    margin: 30px auto;
    background: #222;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(204,0,0,.6);
    display: none;
}
.progress-bar {
    width: 0%;
    height: 30px;
    background: linear-gradient(90deg, #cc0000, #ff4444);
    border-radius: 10px;
    transition: width 0.4s ease;
    position: relative;
}
.progress-text {
    position: absolute;
    width: 100%;
    text-align: center;
    line-height: 30px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 3px black;
}

.skeleton {
    background:#111;
    border-radius:15px;
    padding:15px;
    box-shadow:
        0 0 15px rgba(204,0,0,.25),
        0 10px 25px rgba(0,0,0,.6);

    height: 520px; /* üî• mismo alto que una card real */

    background: linear-gradient(90deg, #111, #222, #111);
    background-size: 200% 100%;
    animation: pulse 1.5s infinite;
}
frames pulse {
    0% { background-position:0% }
    100% { background-position:200% }
}
/* Contenedor que permite el swipe */
.grid-container {
    display: flex;
    transition: transform 0.4s ease;
    width: 100%;
}

/* En desktop: botones visibles, swipe desactivado */
@media (min-width: 769px) {
    .grid-container {
        transform: none !important; /* no swipe en desktop */
    }
}

/* En m√≥vil: preparamos para swipe horizontal */
@media (max-width: 768px) {
    .grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
        width: 100%;
        margin: 0;
    }

    .anime-card img {
        height: 210px;
    }

    .title {
        font-size: 1em;
        -webkit-line-clamp: 3;
        min-height: 3.9em;
    }

    .average {
        font-size: 1.3em;
    }

    /* Ocultar botones de paginaci√≥n en m√≥vil */
    .pagination-buttons {
        display: none !important;
    }

    /* Swipe m√°s suave */
    .grid-container {
        touch-action: pan-y;
    }
}
/* Desktop grande (m√°s de 1024px) - ya ten√©s 5 columnas, lo dejamos como est√° */
</style>
</head>
<body>
<h1>Top 10 Animes por Temporada</h1>
<div id="updateInfo" style="margin: 15px auto; font-size: 1.1em; color: #ff9999; min-height: 1.5em;">
    Pr√≥xima actualizaci√≥n en: <span id="countdown">--:--:--</span>
</div>
<div id="loading" class="loading">Seleccion√° temporada y a√±o</div>
<div class="controls">
    <select id="year"></select>
    <select id="season">
        <option value="winter">Winter</option>
        <option value="spring">Spring</option>
        <option value="summer">Summer</option>
        <option value="fall">Fall</option>
    </select>

    <!-- Checkboxes + dropdown juntos -->
    <div style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; margin: 15px auto;">
        <div class="type-filters" style="font-size: 1.1em; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <label><input type="checkbox" id="type-tv" checked> TV</label>
            <label><input type="checkbox" id="type-ona" checked> ONA</label>
            <label><input type="checkbox" id="type-movie" checked> Movie</label>
            <label><input type="checkbox" id="type-ova" checked> OVA</label>
            <label><input type="checkbox" id="type-special" checked> Special</label>
        </div>

        <!-- Dropdown al lado -->
        <div style="display: flex; align-items: center; gap: 10px; white-space: nowrap;">
            <label for="scoreMode" style="font-size: 1.1em;">Mostrar puntajes como:</label>
            <select id="scoreMode">
                <option value="normal">Del 1 al 10</option>
                <option value="percent">Porcentual</option>
            </select>
        </div>
    </div>

    <div style="display: flex; gap: 15px; align-items: center; justify-content: center; flex-wrap: wrap; margin-top: 15px;">
        <button onclick="loadTop10()">Buscar</button>
        <button id="prevPageBtn" onclick="prevPage()" style="background: linear-gradient(45deg, #444, #666);">
        ‚Üê Anterior
    </button>
    <button id="nextPageBtn" onclick="nextPage()" style="background: linear-gradient(45deg, #444, #666);">
        Siguiente ‚Üí
    </button>
    </div>
</div>

<div id="progressContainer" class="progress-container">
    <div id="progressBar" class="progress-bar">
        <div id="progressText" class="progress-text">0%</div>
    </div>
</div>


<!-- Navegaci√≥n sobre el grid -->
<div id="gridWrapper" style="overflow: hidden; max-width: 1400px; margin: 0 auto; touch-action: pan-y;">
    <div id="gridContainer" class="grid-container" style="display: flex; transition: transform 0.4s ease; width: 100%;">
        <div id="grid" class="grid"></div>
    </div>
</div>


<script>
const CACHE_TTL = 4 * 60 * 60 * 1000;     // 4 horas
const MAX_SEASONS_CACHED = 25;
const BATCH_SIZE = 15;

const grid = document.getElementById('grid');
const loading = document.getElementById('loading');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
let seasonRanking = []; // Lista completa de la temporada
let currentPage = 1;
const itemsPerPage = 10;
let isLoading = false;
let currentLoadPromise = null; // Para poder abortar/cancelar


window.onload = () => {
    const y = document.getElementById('year');
    
    // Llenar el select de a√±os (ejemplo: √∫ltimos 20 a√±os + el actual + pr√≥ximo)
    const currentYear = new Date().getFullYear();
    for (let i = currentYear + 1; i >= currentYear - 20; i--) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i;
        y.appendChild(opt);
    }
    // Seleccionar el a√±o actual por defecto
    y.value = currentYear;

    // Restaurar temporada seleccionada si existe
    const savedSeason = localStorage.getItem('selectedSeason');
    if (savedSeason) {
        document.getElementById('season').value = savedSeason;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Restaurar modo de puntaje
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const savedScoreMode = localStorage.getItem('scoreMode') || 'normal';
    const scoreModeSelect = document.getElementById('scoreMode');
    if (scoreModeSelect) {
        scoreModeSelect.value = savedScoreMode;
        currentScoreMode = savedScoreMode;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Restaurar tipos seleccionados (checkboxes)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const savedTypes = JSON.parse(localStorage.getItem('selectedTypes') || '[]');

    // Si NO hay nada guardado en localStorage ‚Üí tildamos TODOS por defecto
    if (savedTypes.length === 0) {
        document.getElementById('type-tv').checked     = true;
        document.getElementById('type-ona').checked    = true;
        document.getElementById('type-movie').checked  = true;
        document.getElementById('type-ova').checked    = true;
        document.getElementById('type-special').checked = true;
    } else {
        // Restauramos exactamente lo que el usuario guard√≥
        document.getElementById('type-tv').checked     = savedTypes.includes("TV");
        document.getElementById('type-ona').checked    = savedTypes.includes("ONA");
        document.getElementById('type-movie').checked  = savedTypes.includes("Movie");
        document.getElementById('type-ova').checked    = savedTypes.includes("OVA");
        document.getElementById('type-special').checked = savedTypes.includes("Special");
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Guardar cambios en checkboxes cuando el usuario los modifique
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const checkboxes = [
        'type-tv', 'type-ona', 'type-movie', 'type-ova', 'type-special'
    ];
    checkboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.addEventListener('change', () => {
                const selected = getSelectedTypes();
                localStorage.setItem('selectedTypes', JSON.stringify(selected));
            });
        }
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Guardar temporada cuando cambie el select
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    document.getElementById('season').addEventListener('change', function() {
        localStorage.setItem('selectedSeason', this.value);
    });

    // Iniciar countdown (si ya hay temporada y a√±o seleccionados)
    startCountdown();

    // Opcional: si quer√©s cargar autom√°ticamente la temporada actual al abrir la p√°gina,
    // pod√©s descomentar esto (pero como pediste que NO cargue autom√°ticamente, lo dejo comentado)
    // loadTop10();
};

const delay = ms => new Promise(r => setTimeout(r, ms));

function seasonKey(year, season) { return `SEASON_${year}_${season}`; }

function getSeasonCache(key) {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (Date.now() - parsed.timestamp > CACHE_TTL) {
        localStorage.removeItem(key);
        return null;
    }
    parsed.lastUsed = Date.now();
    localStorage.setItem(key, JSON.stringify(parsed));
    return parsed.data;
}

function saveSeasonCache(key, data) {
    localStorage.setItem(key, JSON.stringify({ timestamp: Date.now(), lastUsed: Date.now(), data }));
    cleanupCache();
}

function cleanupCache() {
    const seasons = Object.keys(localStorage)
        .filter(k => k.startsWith('SEASON_'))
        .map(k => ({ key: k, ...JSON.parse(localStorage.getItem(k)) }));
    if (seasons.length <= MAX_SEASONS_CACHED) return;
    seasons.sort((a, b) => a.lastUsed - b.lastUsed)
        .slice(0, seasons.length - MAX_SEASONS_CACHED)
        .forEach(s => localStorage.removeItem(s.key));
}

// Consulta r√°pida a AniList por un solo MAL ID (ponela ANTES de fetchSeasonMAL)
async function getAniListSeason(malId) {
    const query = `
    query ($idMal: Int) {
      Media(idMal: $idMal, type: ANIME) {
        season
        seasonYear
        startDate {
          year
          month
          day
        }
      }
    }`;

    try {
        const res = await fetch('https://graphql.anilist.co', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, variables: { idMal: malId } })
        });

        if (!res.ok) return null;

        const data = await res.json();
        const media = data.data?.Media;

        if (!media) return null;

        return {
            season: media.season,
            seasonYear: media.seasonYear,
            startYear: media.startDate?.year
        };
    } catch (e) {
        console.error('Error fetching AniList season for MAL ID', malId, e);
        return null;
    }
}

async function fetchSeasonFromAniList(year, season) {
    const allowedFormats = getSelectedTypes().map(t => {
        switch (t) {
            case "TV": return "TV";
            case "ONA": return "ONA";
            case "Movie": return "MOVIE";
            case "OVA": return "OVA";
            case "Special": return "SPECIAL";
            default: return null;
        }
    }).filter(Boolean);

    if (allowedFormats.length === 0) return [];

    const aniSeason = season.toUpperCase(); // WINTER, SPRING, SUMMER, FALL

    const query = `
query ($seasonYear: Int, $season: MediaSeason, $formats: [MediaFormat], $page: Int) {
  Page(page: $page, perPage: 50) {
    pageInfo { hasNextPage }
    media(seasonYear: $seasonYear, season: $season, format_in: $formats, type: ANIME, sort: SCORE_DESC) {
      id
      idMal
      title { 
        english 
        romaji 
        native   # ‚Üê AGREGAR ESTO
      }
      averageScore
      format
      episodes
      coverImage { large }
    }
  }
}`;

    let allMedia = [];
    let page = 1;
    let hasNext = true;

    while (hasNext && allMedia.length < 60) {
        try {
            const res = await fetch('https://graphql.anilist.co', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query,
                    variables: { seasonYear: year, season: aniSeason, formats: allowedFormats, page }
                })
            });

            if (!res.ok) break;

            const { data } = await res.json();
            const pageData = data?.Page;

            if (!pageData?.media) break;

            allMedia.push(...pageData.media);
            hasNext = pageData.pageInfo.hasNextPage;
            page++;
            await delay(350); // Rate limit AniList ~90/min, mejor ser conservador
        } catch (e) {
            console.error("Error fetching AniList season", e);
            break;
        }
    }

    // Ordenar por score descendente (aunque ya pedimos sort)
    allMedia.sort((a, b) => (b.averageScore || 0) - (a.averageScore || 0));

    // Mapear a formato compatible con tu c√≥digo actual (para que renderCard y scores funcionen)
    return allMedia.map(m => ({
    mal_id: m.idMal || null,
    titles: {
        english: m.title?.english ?? null,
        romaji:  m.title?.romaji  ?? null,
        native:  m.title?.native  ?? null
    },
    image: m.coverImage?.large || '',
    score: m.averageScore ? (m.averageScore / 10) : null,
    format: m.format,
    episodes: m.episodes,
    al_id: m.id
}));

}


async function fetchAniListBatch(malIds) {
    const results = {};
    const missingIds = [];

    malIds.forEach(malId => {
        const cacheKey = `AL_MAL_${malId}`;
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
            results[malId] = JSON.parse(cached);
        } else {
            missingIds.push(malId);
        }
    });

    if (missingIds.length === 0) return results;

    const query = `
    query ($ids: [Int]) {
      Page {
        media(idMal_in: $ids, type: ANIME) {
          id
          idMal
          averageScore
        }
      }
    }`;

    const batches = [];
    for (let i = 0; i < missingIds.length; i += BATCH_SIZE) {
        batches.push(missingIds.slice(i, i + BATCH_SIZE));
    }

    for (const batch of batches) {
        const variables = { ids: batch };
        const res = await fetch('https://graphql.anilist.co', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, variables })
        });
        if (!res.ok) continue;
        const data = await res.json();
        const mediaList = data.data.Page?.media || [];
        mediaList.forEach(media => {
            const result = {
                id: media.id,
                score: media.averageScore ? (media.averageScore / 10).toFixed(2) : null
            };
            const cacheKey = `AL_MAL_${media.idMal}`;
            localStorage.setItem(cacheKey, JSON.stringify(result));
            results[media.idMal] = result;
        });
        await delay(1000);
    }

    return results;
}


function getManualScore(malId) {
    const key = `MANUAL_AL_${malId}`;
    const val = localStorage.getItem(key);
    return val ? parseFloat(val).toFixed(2) : null;
}

function saveManualScore(malId, score) {
    const key = `MANUAL_AL_${malId}`;
    localStorage.setItem(key, score);
}

function updateProgress(percent, message = '') {
    progressBar.style.width = percent + '%';
    progressText.textContent = `${Math.round(percent)}%${message ? ` ‚Äî ${message}` : ''}`;
}

function renderSkeletons() {
    grid.innerHTML = '';
    for (let i = 0; i < 10; i++) {
        const d = document.createElement('div');
        d.className = 'skeleton';
        grid.appendChild(d);
    }
}

function renderCard(anime, index) {
    const card = document.createElement('div');
    card.className = 'anime-card';
    const rankClass =
    index === 0 ? 'gold' :
    index === 1 ? 'silver' :
    index === 2 ? 'bronze' :
    'red';

    // Score AniList: autom√°tico, manual o N/A
    let alScore = anime.al;
    if (!alScore) {
        alScore = getManualScore(anime.mal_id);
    }
    const hasAlId = anime.al_id !== undefined;
    const finalAlScore = alScore || 'N/A';
   


    // Promedio actualizado con score manual si existe
let malScore = anime.mal != null && !isNaN(parseFloat(anime.mal)) ? parseFloat(anime.mal) : null;
let alFinal  = alScore != null ? parseFloat(alScore) : null;

let avgNum = 0;
let count = 0;
if (malScore != null) { avgNum += malScore; count++; }
if (alFinal  != null) { avgNum += alFinal;  count++; }

const avg = count === 2 ? (avgNum / 2).toFixed(2) :
            count === 1 ? avgNum.toFixed(2) :
            'N/A';

    card.innerHTML = `
    <div class="rank ${rankClass}">#${index + 1}</div>
    <img src="${anime.image}">
    <div class="title">${anime.title}</div>
    <div class="scores">
        MAL: ${anime.mal} |
        AniList: 
        ${alScore 
            ? `<span>${alScore}</span>`
            : hasAlId 
                ? `<span class="al-score" onclick="editAlScore(${anime.mal_id}, this)">${finalAlScore} (editar)</span>`
                : `<span>${finalAlScore}</span>`
        }
        
    </div>
    <div class="bottom">
    <div class="average">‚≠ê ${avg}</div>
    <div class="links">
        <a href="https://myanimelist.net/anime/${anime.mal_id}" target="_blank">MAL</a>
        ${hasAlId ? `<a href="https://anilist.co/anime/${anime.al_id}" target="_blank">AniList</a>` : ''}
    </div>
</div>
`;

    grid.appendChild(card);
}

function renderPage(page) {
    if (!seasonRanking.length) return;
    const start = (page - 1) * itemsPerPage;
    const end = start + itemsPerPage;
    const pageItems = seasonRanking.slice(start, end);

    grid.innerHTML = '';
    pageItems.forEach((anime, i) => renderCard(anime, start + i));

    updatePageButtons();
}

// Funci√≥n global para editar score
function editAlScore(malId, element) {
    const current = element.textContent.trim();
    const newText = current.includes('editar') ? '' : current;

    const input = document.createElement('input');
    input.type = 'number';
    input.step = '0.01';
    input.min = '0';
    input.max = '10';
    input.value = newText === 'N/A' || newText === '' ? '' : newText;
    input.className = 'edit-input';

    input.onblur = () => {
        let value = input.value.trim();
        if (value && parseFloat(value) >= 0 && parseFloat(value) <= 10) {
            value = parseFloat(value).toFixed(2);
            saveManualScore(malId, value);
            element.textContent = value;
        } else {
            element.textContent = 'N/A (editar)';
        }
        input.remove();
        // Recalcular todo el top con el nuevo promedio
        loadTop10(); // Recarga para reordenar si cambi√≥ el promedio
    };

    input.onkeydown = (e) => {
        if (e.key === 'Enter') input.blur();
        if (e.key === 'Escape') {
            element.textContent = 'N/A (editar)';
            input.remove();
        }
    };

    element.textContent = '';
    element.appendChild(input);
    input.focus();
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Funciones de cach√© para MAL (necesarias para loadTop10)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function getMalCache(id) {
    const raw = localStorage.getItem(`MAL_FULL_${id}`);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (Date.now() - parsed.timestamp > CACHE_TTL) {
        localStorage.removeItem(`MAL_FULL_${id}`);
        return null;
    }
    return parsed.data;
}

function saveMalCache(id, data) {
    localStorage.setItem(`MAL_FULL_${id}`, JSON.stringify({
        timestamp: Date.now(),
        data
    }));
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// loadTop10() COMPLETA - Versi√≥n corregida y robusta
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function loadTop10() {
    // Si ya hay una carga en curso, marcamos para interrumpirla
    if (isLoading) {
        console.log("Carga en curso detectada ‚Üí interrumpiendo la anterior");
        isLoading = false; // La anterior dejar√° de actualizar el DOM
    }

    isLoading = true;

    // Guardamos la promesa para poder referenciarla si se cancela
    currentLoadPromise = (async () => {
        try {
            const year = parseInt(document.getElementById('year').value);
            const season = document.getElementById('season').value;
            if (!year || !season) {
                loading.textContent = "Seleccion√° temporada y a√±o";
                return;
            }

            const key = seasonKey(year, season);
            let seasonData = getSeasonCache(key);

            progressContainer.style.display = 'block';
            updateProgress(0, 'Iniciando...');

            if (!seasonData) {
                renderSkeletons();

                // Etapa 1: AniList ‚Üí 0% a 30%
updateProgress(5, 'Consultando...');
const aniList = await fetchSeasonFromAniList(year, season);
if (!isLoading) return;
updateProgress(30, 'Datos obtenidos');

// ‚îÄ‚îÄ FILTRAMOS CANDIDATOS ANTES DE FETCHEARE MAL ‚îÄ‚îÄ
const candidates = aniList.filter(ani => {
    // Incluimos si:
    // 1. Tiene score en AniList (aunque sea bajo)
    // 2. O tiene mal_id v√°lido (podr√≠a tener score solo en MAL)
    // 3. O tiene score manual previo (opcional, pero √∫til)
    const hasAlScore = ani.score && ani.score > 0;
    const hasMalId   = ani.mal_id && ani.mal_id > 0;
    const hasManual  = getManualScore(ani.mal_id) !== null;

    return hasAlScore || hasMalId || hasManual;
});

updateProgress(32, `Filtrados ${candidates.length} animes con potencial score`);

const malIdsToFetch = candidates
    .filter(a => a.mal_id)
    .map(a => a.mal_id);

// Ahora solo fetcheamos estos (mucho menos que el total original)
const totalMal = malIdsToFetch.length;
let processedMal = 0;
const malDataById = {};

if (totalMal === 0) {
    updateProgress(85, 'No hay datos');
} else {
    updateProgress(35, `Obteniendo datos para ${totalMal} candidatos...`);

    for (const id of malIdsToFetch) {
        if (!isLoading) break;

        let malData = getMalCache(id);

        if (!malData) {
            let attempts = 0;
            while (attempts < 3) {
                try {
                    const res = await fetch(`https://api.jikan.moe/v4/anime/${id}/full`);
                    
                    if (res.status === 429) {
                        console.warn(`429 en MAL ID ${id} ‚Üí esperando ${5 * (attempts + 1)}s`);
                        await delay(5000 * (attempts + 1));
                        attempts++;
                        continue;
                    }
                    
                    if (res.ok) {
                        const data = await res.json();
                        malData = data.data;
                        saveMalCache(id, malData);
                        await delay(1000); // 1 req/seg
                        break;
                    }
                    
                    console.warn(`Error ${res.status} en MAL ID ${id}`);
                    break;
                } catch (e) {
                    console.error("Error fetching MAL for", id, e);
                    break;
                }
                attempts++;
                await delay(1500);
            }
        }

        if (malData) malDataById[id] = malData;

        processedMal++;
        const malProgress = 30 + (55 * (processedMal / totalMal));
        updateProgress(Math.min(85, malProgress), `Procesando (${processedMal} de ${totalMal})`);
    }
}

updateProgress(85, 'Datos completados');

// ‚îÄ‚îÄ Usamos candidates en vez de aniList para el resto ‚îÄ‚îÄ
const enrichedList = candidates.map(ani => {
    const mal = ani.mal_id ? malDataById[ani.mal_id] : null;

    let title = null;
    if (mal?.title_english && mal.title_english.trim() !== '') {
        title = mal.title_english.trim();
    } else if (mal?.title && mal.title.trim() !== '') {
        title = mal.title.trim();
    } else if (ani.titles?.english) {
        title = ani.titles.english;
    } else if (ani.titles?.romaji) {
        title = ani.titles.romaji;
    } else if (ani.titles?.native) {
        title = ani.titles.native;
    } else {
        title = "Sin t√≠tulo";
    }

    let imageUrl = ani.image ||
                   (mal?.images?.jpg?.large_image_url ||
                    'https://via.placeholder.com/300x450?text=Sin+Imagen');

    return {
        mal_id: ani.mal_id,
        title: title.trim() || "Sin t√≠tulo",
        image: imageUrl,
        mal: mal?.score ? parseFloat(mal.score.toFixed(2)) : null,
        al: ani.score ? ani.score.toFixed(2) : null,
        al_id: ani.al_id,
        type: ani.format || 'Unknown'
    };
});
                

                updateProgress(90, 'Calculando promedios...');

                const processed = enrichedList
                    .map(ani => {
                        const malScoreRaw = ani.mal ?? null;
                        let alScoreRaw = ani.al ?? getManualScore(ani.mal_id);

                        const malNum = malScoreRaw != null && !isNaN(malScoreRaw) ? parseFloat(malScoreRaw) : null;
                        const alNum  = alScoreRaw  != null && !isNaN(alScoreRaw)  ? parseFloat(alScoreRaw)  : null;

                        if (malNum === null && alNum === null) {
                            return null;
                        }

                        let avgNum = 0;
                        let sourcesCount = 0;
                        if (malNum != null) { avgNum += malNum; sourcesCount++; }
                        if (alNum  != null) { avgNum += alNum;  sourcesCount++; }
                        if (sourcesCount > 0) avgNum /= sourcesCount;

                        return {
                            title: ani.title || "Sin t√≠tulo",
                            image: ani.image || 'https://via.placeholder.com/300x450?text=Sin+Imagen',
                            mal: malNum != null ? malNum.toFixed(2) : 'N/A',
                            al: alNum != null ? alNum.toFixed(2) : 'N/A',
                            avg: avgNum.toFixed(2),
                            mal_id: ani.mal_id,
                            al_id: ani.al_id
                        };
                    })
                    .filter(anime => anime !== null);

                updateProgress(94, 'Ordenando ranking final...');

                seasonRanking = processed.sort((a, b) => {
                    if (b.avg !== a.avg) return b.avg - a.avg;
                    const maxA = Math.max(parseFloat(a.mal || 0), parseFloat(a.al || 0));
                    const maxB = Math.max(parseFloat(b.mal || 0), parseFloat(b.al || 0));
                    if (maxB !== maxA) return maxB - maxA;
                    return a.title.localeCompare(b.title);
                });

                saveSeasonCache(key, seasonRanking);

                // Sprint final
                updateProgress(96);
                await delay(300);
                updateProgress(98);
                await delay(250);
                updateProgress(100, '¬°Listo!');
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    loading.textContent = '';
                }, 600);

            } else {
                // Desde cach√©
                seasonRanking = seasonData;
                updateProgress(40);
                await delay(200);
                updateProgress(70, 'Cargando desde cach√©...');
                await delay(300);
                updateProgress(100, '¬°Listo!');
                setTimeout(() => progressContainer.style.display = 'none', 400);
            }

            if (!isLoading) return; // No renderizamos si se cancel√≥

            // Guardamos la p√°gina actual antes de renderizar
            const pageToRender = currentPage;

            currentPage = 1;
            grid.innerHTML = '';
            renderPage(pageToRender);
            currentPage = pageToRender;
            updatePageButtons();

            startCountdown();
        } catch (err) {
            console.error("Error en loadTop10:", err);
            loading.textContent = 'Error al cargar la temporada';
        } finally {
            isLoading = false;
            currentLoadPromise = null;
        }
    })();

    return currentLoadPromise;
}
// Retorna milisegundos restantes hasta que expire el cach√© de esta temporada
function getTimeUntilNextUpdate(year, season) {
    if (!year || !season) return 0;
    
    const key = seasonKey(year, season);
    const raw = localStorage.getItem(key);
    if (!raw) return CACHE_TTL; // si no hay cach√© ‚Üí como si acabara de empezar
    
    const parsed = JSON.parse(raw);
    const expiresAt = parsed.timestamp + CACHE_TTL;
    const remaining = expiresAt - Date.now();
    
    return Math.max(0, remaining);
}

// Formatea milisegundos a "Xh Ym Zs" o "menos de 1 minuto", etc.
function formatRemainingTime(ms) {
    if (ms <= 0) return "¬°Ahora! (recarga para actualizar)";
    
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours   = Math.floor(minutes / 60);
    
    const s = seconds % 60;
    const m = minutes % 60;
    const h = hours;
    
    if (h > 0) {
        return `${h}h ${m}m ${s}s`;
    } else if (m > 0) {
        return `${m}m ${s}s`;
    } else {
        return `${s}s`;
    }
}

// Inicia y actualiza el countdown cada segundo
let countdownInterval = null;

function startCountdown() {
    const year = document.getElementById('year')?.value;
    const season = document.getElementById('season')?.value;
    
    if (!year || !season) {
        document.getElementById('countdown').textContent = "‚Äî";
        return;
    }
    
    const updateCountdown = () => {
        const remainingMs = getTimeUntilNextUpdate(year, season);
        document.getElementById('countdown').textContent = formatRemainingTime(remainingMs);
        
        // Opcional: si llega a 0, podr√≠as cambiar color o texto
        if (remainingMs <= 0) {
            document.getElementById('updateInfo').style.color = '#66ff66';
        }
    };
    
    updateCountdown(); // inmediato
    
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(updateCountdown, 1000);
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// NUEVO: Sistema de puntajes normal vs porcentual (versi√≥n corregida y robusta)

let currentScoreMode = localStorage.getItem('scoreMode') || 'normal';

// Seteamos el valor inicial del select
const scoreModeSelect = document.getElementById('scoreMode');
if (scoreModeSelect) {
    scoreModeSelect.value = currentScoreMode;
}

scoreModeSelect?.addEventListener('change', function() {
    currentScoreMode = this.value;
    localStorage.setItem('scoreMode', currentScoreMode);

    // Si hay contenido real cargado ‚Üí re-renderizamos manteniendo la p√°gina actual
    if (grid.children.length > 0 && !grid.querySelector('.skeleton')) {
        const year = parseInt(document.getElementById('year')?.value);
        const season = document.getElementById('season')?.value;
        if (year && season) {
            const cached = getSeasonCache(seasonKey(year, season));
            if (cached) {
                const oldPage = currentPage; // ‚Üê Guardamos la p√°gina actual
                grid.innerHTML = '';
                renderPage(oldPage); // ‚Üê Renderizamos la misma p√°gina
                currentPage = oldPage; // Restauramos
                updatePageButtons();
            }
        }
    }
});

// Override seguro de renderCard (se define DESPU√âS de la funci√≥n original)
// Override seguro de renderCard
const originalRenderCard = renderCard;
renderCard = function(anime, index) {
    originalRenderCard(anime, index);

    const card = grid.lastElementChild;
    if (!card) return;

    const malTextNode = card.querySelector('.scores').childNodes[0]; // "MAL: xx.xx | "
    const alElement   = card.querySelector('.scores span');
    const avgElement  = card.querySelector('.average');

    // Valores seguros (igual que en processed y renderCard original)
    // Valores seguros
const malVal = anime.mal !== 'N/A' && !isNaN(parseFloat(anime.mal)) ? parseFloat(anime.mal) : null;
const alVal  = anime.al  !== 'N/A' && !isNaN(parseFloat(anime.al))  ? parseFloat(anime.al)  : null;

// Promedio
let avgNum = 0;
let sources = 0;
if (malVal !== null) { avgNum += malVal; sources++; }
if (alVal  !== null) { avgNum += alVal;  sources++; }

const avgRaw = sources === 2 ? avgNum / 2 :
               sources === 1 ? avgNum :
               null;

// Formateador (ahora maneja N/A correctamente)
const format = (num) => {
    if (num === null) return 'N/A';
    const formatted = currentScoreMode === 'percent'
        ? (num * 10).toFixed(2) + '%'
        : num.toFixed(2);
    return formatted;
};

// Actualizar textos
if (malTextNode) {
    malTextNode.textContent = `MAL: ${format(malVal)} | AniList: `;
}
if (alElement) {
    alElement.textContent = format(alVal);
    if (alElement.classList.contains('al-score') && alVal === null) {
        alElement.textContent = 'N/A (editar)';
    }
}
if (avgElement) {
    avgElement.textContent = `‚≠ê ${format(avgRaw)}`;
}
};
// FIN NUEVO (versi√≥n corregida)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getSelectedTypes() {
    const types = [];
    if (document.getElementById('type-tv').checked)     types.push("TV");
    if (document.getElementById('type-ona').checked)    types.push("ONA");
    if (document.getElementById('type-movie').checked)  types.push("Movie");
    if (document.getElementById('type-ova').checked)    types.push("OVA");
    if (document.getElementById('type-special').checked) types.push("Special");
    return types;
}
function prevPage() {
    if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
        updatePageButtons();
    }
}

function nextPage() {
    if (currentPage * itemsPerPage < seasonRanking.length) {
        currentPage++;
        renderPage(currentPage);
        updatePageButtons();
    }
}

function updatePageButtons() {
    document.getElementById('prevPageBtn').disabled = currentPage === 1;
    document.getElementById('nextPageBtn').disabled = currentPage * itemsPerPage >= seasonRanking.length;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Navegaci√≥n con swipe (solo en m√≥vil) y flechas del teclado
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let touchStartX = 0;
let touchEndX = 0;
const swipeThreshold = 50; // p√≠xeles m√≠nimos para considerar swipe

const gridWrapper = document.getElementById('gridWrapper');
const gridContainer = document.getElementById('gridContainer');

// Solo activamos swipe en pantallas peque√±as
if (window.innerWidth <= 768) {
    gridWrapper.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
    });

    gridWrapper.addEventListener('touchend', e => {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
    });
}

function handleSwipe() {
    if (touchStartX - touchEndX > swipeThreshold) {
        // Swipe izquierda ‚Üí siguiente p√°gina
        nextPage();
    }
    if (touchEndX - touchStartX > swipeThreshold) {
        // Swipe derecha ‚Üí p√°gina anterior
        prevPage();
    }
}

// Soporte para flechas del teclado (en desktop y m√≥vil)
document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') {
        prevPage();
        e.preventDefault();
    } else if (e.key === 'ArrowRight') {
        nextPage();
        e.preventDefault();
    }
});

// Actualizamos la clase active para que el swipe funcione solo cuando hay m√°s de una p√°gina
function updatePageButtons() {
    document.getElementById('prevPageBtn').disabled = currentPage === 1;
    document.getElementById('nextPageBtn').disabled = currentPage * itemsPerPage >= seasonRanking.length;

    // En m√≥vil mostramos visualmente si hay m√°s p√°ginas (opcional)
    if (window.innerWidth <= 768) {
        gridWrapper.classList.toggle('has-prev', currentPage > 1);
        gridWrapper.classList.toggle('has-next', currentPage * itemsPerPage < seasonRanking.length);
    }
}

</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c30e57fddaff3fe',t:'MTc2OTI3MjAzOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>